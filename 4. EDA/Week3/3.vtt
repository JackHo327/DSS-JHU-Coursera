WEBVTT

1
00:00:01.010 --> 00:00:05.520
R 默认输出的聚类树状图 (cluster dendrogram) 还是相对清晰易懂的

2
00:00:05.520 --> 00:00:08.368
不过还能再改进一下

3
00:00:08.368 --> 00:00:11.220
课程网站上有一个 myplclust 函数

4
00:00:11.220 --> 00:00:13.140
大家可以直接从课程网站上下载

5
00:00:13.140 --> 00:00:14.850
用 source 命令将其载入 R 以后

6
00:00:14.850 --> 00:00:16.470
便可以使用这个函数

7
00:00:16.470 --> 00:00:19.930
来输出一个聚类树状图

8
00:00:19.930 --> 00:00:22.260
每个簇里边的所有点

9
00:00:22.260 --> 00:00:25.260
都会由它们所在簇的标签来标记

10
00:00:25.260 --> 00:00:26.140
并且会由不同的颜色来表现

11
00:00:26.140 --> 00:00:29.860
因此可以看到第一类都被标注为 "1"

12
00:00:29.860 --> 00:00:33.790
并且都是黑色

13
00:00:33.790 --> 00:00:37.600
第二和第三类则分别是红色和绿色

14
00:00:38.790 --> 00:00:43.270
当然 为了做到这一点

15
00:00:43.270 --> 00:00:45.902
你需要在实际标注 "1" "2" "3" 之前

16
00:00:45.902 --> 00:00:48.313
指明一共有多少类

17
00:00:48.313 --> 00:00:57.164
 大家还可以去 RGraphGallery 页面

18
00:00:57.164 --> 00:01:00.140
大家还可以去 RGraphGallery 页面

19
00:01:00.140 --> 00:01:02.620
查看一些更为有趣的聚类树状图

20
00:01:02.620 --> 00:01:05.640
看看其他人为了创建简洁明了的聚类树状图

21
00:01:05.640 --> 00:01:07.580
都用过哪些软件

22
00:01:07.580 --> 00:01:11.340
比如你可以看看这个在叶节点上注有标签

23
00:01:11.340 --> 00:01:15.290
并被分组上了色的聚类树状图 

24
00:01:15.290 --> 00:01:17.170
它还被添注了一些其它信息

25
00:01:17.170 --> 00:01:18.410
你可以看一眼这个图库

26
00:01:18.410 --> 00:01:20.150
里面包含了许多不错的图像

27
00:01:22.430 --> 00:01:24.540
关于使用层次聚类的另一个问题便是

28
00:01:24.540 --> 00:01:27.980
如何把点合并到一起

29
00:01:27.980 --> 00:01:30.280
这里的问题就在于

30
00:01:30.280 --> 00:01:35.890
把点合并到一起后 它的新坐标是什么

31
00:01:35.890 --> 00:01:39.380
一种方法是 Average Linkage 聚类法

32
00:01:39.380 --> 00:01:41.730
它的想法就是当两个点合并产生一个新点

33
00:01:41.730 --> 00:01:43.657
该新点的坐标便是

34
00:01:43.657 --> 00:01:45.511
先前两点的 x 坐标和 y 坐标的平均值

35
00:01:45.511 --> 00:01:47.743
所以它有点像重心

36
00:01:47.743 --> 00:01:52.393
或者说是那一组点的中点 这看上去很合理

37
00:01:52.393 --> 00:01:56.722
它也会产生某类特定的聚类结果

38
00:01:56.722 --> 00:02:04.050
另一种方法叫做 Complete Linkage 聚类法

39
00:02:04.050 --> 00:02:08.070
想法就是如果你要测量两个簇之间的距离

40
00:02:08.070 --> 00:02:10.740
你可以取这两个簇中

41
00:02:10.740 --> 00:02:13.630
距离最远的两个点 作为两簇之间的距离

42
00:02:13.630 --> 00:02:15.770
打个比方 在这幅图中

43
00:02:15.770 --> 00:02:17.840
如果你观察上半部分的簇和左下的簇

44
00:02:17.840 --> 00:02:20.790
这两个簇之间的距离就等于

45
00:02:20.790 --> 00:02:24.240
最远的两个点之间的距离

46
00:02:24.240 --> 00:02:28.920
这就是 Complete Linkage 聚类法的概念

47
00:02:28.920 --> 00:02:30.500
而在 Average Linkage 聚类法中

48
00:02:30.500 --> 00:02:33.850
你得到的则是两个重心之间的距离

49
00:02:33.850 --> 00:02:36.000
也就是图中两个加号之间的距离

50
00:02:36.000 --> 00:02:39.500
大家可以看到 Complete Linkage 聚类法

51
00:02:39.500 --> 00:02:41.300
这个例子中的距离相对来说更远

52
00:02:41.300 --> 00:02:45.380
而在 Average Linkage 聚类法的例子中 距离相对更短

53
00:02:45.380 --> 00:02:48.650
这并不代表两个方法中谁对谁错

54
00:02:48.650 --> 00:02:50.419
我的目的在于向大家展示

55
00:02:50.419 --> 00:02:53.530
两种不同的合并方式

56
00:02:53.530 --> 00:02:55.909
能得出差异非常大的结果

57
00:02:55.909 --> 00:02:59.230
所以大家通常应该两种方法都尝试

58
00:02:59.230 --> 00:03:01.668
看看最后得到的不同结果

59
00:03:01.668 --> 00:03:04.290
比较一下哪一个相对更为合理

60
00:03:06.370 --> 00:03:08.640
这里我想重点提出的最后一个函数是 heatmap 函数

61
00:03:08.640 --> 00:03:12.320
该函数对于矩阵数据可视化非常有用

62
00:03:12.320 --> 00:03:14.725
如果你有一个极其庞大的表格

63
00:03:14.725 --> 00:03:18.300
或者类似大小的数字矩阵

64
00:03:18.300 --> 00:03:20.835
并希望快速但有条理地观察它们

65
00:03:20.835 --> 00:03:24.750
你便可以调用 heatmap 函数

66
00:03:24.750 --> 00:03:28.349
这一函数实际上就是在表格的行和列上

67
00:03:28.349 --> 00:03:31.460
运行层次聚类分析

68
00:03:31.460 --> 00:03:32.920
试想一下

69
00:03:32.920 --> 00:03:38.930
矩阵的行就有如观测值

70
00:03:38.930 --> 00:03:43.140
heatmap 函数对这些行进行聚类分析

71
00:03:43.140 --> 00:03:47.570
接着再把表格的列看作为观测值

72
00:03:47.570 --> 00:03:50.990
即使它们实际并不是观测值

73
00:03:50.990 --> 00:03:53.700
那些列可能是变量或类似的东西

74
00:03:53.700 --> 00:03:55.760
但我们可以将它们视为不同的观测值

75
00:03:55.760 --> 00:03:56.570
然后也可以对它们进行聚类分析

76
00:03:56.570 --> 00:03:58.480
然后也可以对它们进行聚类分析

77
00:03:58.480 --> 00:04:00.180
heatmap 函数的原理就在于

78
00:04:00.180 --> 00:04:03.890
使用层次聚类函数

79
00:04:03.890 --> 00:04:07.570
来整理表格的行和列 使我们能够将其可视化

80
00:04:07.570 --> 00:04:09.870
用 image 函数将表格中的

81
00:04:09.870 --> 00:04:13.330
某些组或某些块内的观测值进行可视化

82
00:04:13.330 --> 00:04:17.200
那么 heatmap 函数会生成一个图像

83
00:04:17.200 --> 00:04:18.970
并根据层次聚类算法

84
00:04:18.970 --> 00:04:23.300
对表格中的行和列进行重排

85
00:04:23.300 --> 00:04:28.420
好比在这里就能看到 这些行的旁边

86
00:04:28.420 --> 00:04:30.420
有一个聚类树状图

87
00:04:30.420 --> 00:04:33.020
说明可能存在三个簇

88
00:04:33.020 --> 00:04:35.880
这些行都分别被组合在了一起

89
00:04:35.880 --> 00:04:37.550
然后在数据框里一共只有两列

90
00:04:37.550 --> 00:04:41.935
所以这里对列做聚类分析的意义不十分明显

91
00:04:41.935 --> 00:04:44.140
但如果你有很多列

92
00:04:44.140 --> 00:04:45.520
你便会希望重新整理这些列

93
00:04:45.520 --> 00:04:46.810
使得相互间距离小的列离得更近

94
00:04:46.810 --> 00:04:48.300
而相互间距离大的列则离得更远

95
00:04:48.300 --> 00:04:49.560
而相互间距离大的列则离得更远

96
00:04:49.560 --> 00:04:51.980
所以 heatmap 函数对于

97
00:04:51.980 --> 00:04:56.010
高维数据表的快速可视化是非常有效的

98
00:04:58.650 --> 00:05:01.360
下面是对于层次聚类的总结

99
00:05:01.360 --> 00:05:04.410
对于观察高维数据来说 它是一个很有用的技巧

100
00:05:04.410 --> 00:05:06.340
它能把数据整合得直观且有条理

101
00:05:06.340 --> 00:05:09.930
尤其是类似于 heatmap 之类的函数

102
00:05:09.930 --> 00:05:12.720
十分适用于快速观察表格或矩阵数据

103
00:05:12.720 --> 00:05:15.210
十分适用于快速观察表格或矩阵数据

104
00:05:17.010 --> 00:05:19.320
当然 你需要先定义出

105
00:05:19.320 --> 00:05:22.780
两点之间远近的意义

106
00:05:22.780 --> 00:05:23.670
另外还需要一个合并策略

107
00:05:23.670 --> 00:05:24.750
另外还需要一个合并策略

108
00:05:24.750 --> 00:05:27.300
我们已经讨论了 Complete Linkage 和 Average Linkage 聚类法

109
00:05:27.300 --> 00:05:29.470
有了这两种聚类法

110
00:05:29.470 --> 00:05:33.150
我们便可运行层次聚类算法 产生聚类树状图

111
00:05:33.150 --> 00:05:35.510
并展示合并是如何进行的

112
00:05:35.510 --> 00:05:38.780
也就是点是如何通过聚类算法合并到一起的

113
00:05:39.870 --> 00:05:42.890
说到层次聚类就有这么一个问题

114
00:05:42.890 --> 00:05:45.960
这一问题常常也存在于其它许多聚类算法中

115
00:05:45.960 --> 00:05:49.120
即聚类图像存在不稳定性

116
00:05:49.120 --> 00:05:51.070
好比 如果几个点需要产生变化

117
00:05:51.070 --> 00:05:52.760
或者如果存在偏值

118
00:05:53.870 --> 00:05:57.850
那么如果你去除了这些点

119
00:05:57.850 --> 00:05:58.940
或稍微改变了它们

120
00:05:58.940 --> 00:06:00.810
那么聚类树状图

121
00:06:00.810 --> 00:06:02.910
或层次聚类法的最后结果可能就会改变很多

122
00:06:02.910 --> 00:06:04.750
你必须将这一点也加以考量

123
00:06:06.650 --> 00:06:10.260
所以尝试不同的距离度量

124
00:06:10.260 --> 00:06:14.380
来观察数据对于不同距离度量的敏感程度

125
00:06:14.380 --> 00:06:15.840
通常是非常有用的

126
00:06:15.840 --> 00:06:17.720
也可以看看改变了合并策略后

127
00:06:17.720 --> 00:06:21.280
产生的不同图像

128
00:06:21.280 --> 00:06:24.890
另外变量的数量级对于聚类算法也非常重要

129
00:06:24.890 --> 00:06:27.180
所以如果一个变量的单位

130
00:06:27.180 --> 00:06:30.360
比其它变量大得多

131
00:06:30.360 --> 00:06:33.310
有时就可能会干扰到算法

132
00:06:33.310 --> 00:06:35.620
所以有时候我们需要调整某些变量的数量级

133
00:06:35.620 --> 00:06:38.440
使它们更具有可比性

134
00:06:39.550 --> 00:06:41.610
层次聚类的好处之一便是

135
00:06:41.610 --> 00:06:42.980
至少就我们在这里所讨论了的算法而言

136
00:06:42.980 --> 00:06:44.440
它是一个确定性算法 没有随机的起始点

137
00:06:44.440 --> 00:06:46.830
不存在随机性

138
00:06:46.830 --> 00:06:49.050
在运行了一次后

139
00:06:49.050 --> 00:06:51.330
以同样的参数和数据再运行 它会产生同样的图片

140
00:06:52.712 --> 00:06:55.493
当然 任何聚类算法都有一个关键问题

141
00:06:55.493 --> 00:06:59.550
就是在哪里进行截断

142
00:06:59.550 --> 00:07:03.600
一般的想法是 先判断一共有多少簇

143
00:07:03.600 --> 00:07:04.850
我们并不能总是很容易地

144
00:07:04.850 --> 00:07:06.525
判断一共有多少簇

145
00:07:06.525 --> 00:07:11.150
不过还是有一些算法

146
00:07:11.150 --> 00:07:14.030
可以用来找出聚类的数量

147
00:07:14.030 --> 00:07:16.280
但我觉得层次聚类最大的优势

148
00:07:16.280 --> 00:07:18.930
可能就在于探索性分析

149
00:07:18.930 --> 00:07:21.430
也就是观察数据、进行可视化

150
00:07:21.430 --> 00:07:24.110
并观测出可能存在的模式

151
00:07:24.110 --> 00:07:25.700
你可以带着这些想法

152
00:07:25.700 --> 00:07:28.470
之后在更复杂的模型中运用它们

153
00:07:28.470 --> 00:07:30.250
我在这里给出了一些链接

154
00:07:30.250 --> 00:07:31.740
里面对上述算法给出了更详细的说明

155
00:07:31.740 --> 00:07:33.860
我建议大家点进去看一看 做更多的探索
【教育无边界字幕组】 RRD16 | LennyBear | hazard1990