WEBVTT

1
00:00:01.120 --> 00:00:03.620
说到图形设备

2
00:00:03.620 --> 00:00:05.960
大体可以将它们分为两大类

3
00:00:05.960 --> 00:00:08.870
一类是矢量设备 (vector device)

4
00:00:08.870 --> 00:00:11.564
或称矢量格式 (vector format) 另一类格式是位图 (bitmap)

5
00:00:11.564 --> 00:00:15.510
矢量格式主要用于线状图形 (line graphics)

6
00:00:15.510 --> 00:00:16.950
如果你有个散点图

7
00:00:16.950 --> 00:00:20.280
在上面添加回归线什么的 这些都属于线状图

8
00:00:20.280 --> 00:00:23.820
它们与自然场景、 图像或照片等不同

9
00:00:23.820 --> 00:00:26.480
它们与自然场景、图像或照片等不同

10
00:00:26.480 --> 00:00:29.050
以矢量格式生成这些图形非常有用

11
00:00:29.050 --> 00:00:33.720
因为能轻易调整大小

12
00:00:33.720 --> 00:00:36.530
不论是放大或缩小

13
00:00:36.530 --> 00:00:38.660
都不会使图片扭曲失真

14
00:00:38.660 --> 00:00:40.880
并且画质也不会受到影响

15
00:00:41.970 --> 00:00:44.190
例如 PDF 格式的可移植性就非常好

16
00:00:44.190 --> 00:00:48.370
几乎能在市面上所有平台上使用

17
00:00:48.370 --> 00:00:50.980
它是一个通用矢量格式 相当不错

18
00:00:52.240 --> 00:00:54.400
如果一张图上有大量的点

19
00:00:54.400 --> 00:00:57.310
那么通常情况下矢量格式就不是一种很好的选择

20
00:00:57.310 --> 00:01:00.900
因为矢量图中的每一个点

21
00:01:00.900 --> 00:01:04.800
都需要用一些信息来表征

22
00:01:04.800 --> 00:01:08.550
因此 如果一个矢量格式文件中有大量的点

23
00:01:08.550 --> 00:01:12.482
那么文件就会变得非常大

24
00:01:12.482 --> 00:01:15.050
可缩放矢量图形格式 (scalable vector graphic) 简称 SVG

25
00:01:15.050 --> 00:01:17.680
在网络上的绘图中非常常见

26
00:01:17.680 --> 00:01:21.050
这种格式非常有用 因为它支持图形中的动画和交互等功能

27
00:01:22.340 --> 00:01:27.500
几乎所有的网页浏览器上都能识别 SVG 格式的图像

28
00:01:27.500 --> 00:01:31.780
Windows 图元文件格式 (Windows MetaFile) 是个只能在 Windows 系统中使用的矢量格式

29
00:01:33.510 --> 00:01:38.200
稍微老旧一些的文件格式还有 PostScript 格式

30
00:01:38.200 --> 00:01:40.150
这个格式可以说是 PDF 格式的前身

31
00:01:40.150 --> 00:01:42.359
虽然并不怎么常用 但还是能经常看到

32
00:01:45.628 --> 00:01:49.610
位图也有几种常见的文件格式

33
00:01:49.610 --> 00:01:54.760
最常见的应该就是 PNG 格式了 它是 Portable Network Graphics (便携网络图形) 的缩写

34
00:01:54.760 --> 00:01:58.200
基本来说 在位图中

35
00:01:58.200 --> 00:02:01.570
图形和图片都由一系列像素表征

36
00:02:01.570 --> 00:02:06.990
这类格式非常适合含有大量点的图形

37
00:02:06.990 --> 00:02:10.690
这类格式非常适合含有大量点的图形

38
00:02:10.690 --> 00:02:13.074
因为位图格式可以很有效率地表现这些点

39
00:02:13.074 --> 00:02:16.170
PNG 格式对线条 (line drawing) 和纯色图像之类的非常合适

40
00:02:16.170 --> 00:02:20.040
它使用的是一种无损压缩算法 (lossless compression algorithm)

41
00:02:20.040 --> 00:02:21.925
因此文件体积通常比较小

42
00:02:21.925 --> 00:02:25.158
而且目前可以说所有网页浏览器都能读取 PNG 格式的图片

43
00:02:25.158 --> 00:02:28.196
因此对放在网络上的图像来说非常合适

44
00:02:28.196 --> 00:02:29.430
如果你有数码相机之类的设备

45
00:02:29.430 --> 00:02:32.546
可能会对 JPEG 格式更加熟悉

46
00:02:32.546 --> 00:02:34.776
这一格式对自然场景之类的图像非常合适

47
00:02:34.776 --> 00:02:35.832
这类图像中有许多渐变色 而非单色

48
00:02:35.832 --> 00:02:39.010
这类图像中有许多渐变色 而非单色

49
00:02:39.010 --> 00:02:41.360
它采用的则是有损压缩算法 (loosy compression algorithm)

50
00:02:41.360 --> 00:02:45.710
所以文件体积可以有效地压缩成非常小

51
00:02:45.710 --> 00:02:47.000
而因为它是位图格式的一种

52
00:02:47.000 --> 00:02:48.890
所以在绘制由大量点组成的图形时非常有用

53
00:02:50.020 --> 00:02:53.580
位图格式通常在缩放方面有欠缺 因此当你在生成了一个图形后

54
00:02:53.580 --> 00:02:58.580
再试图放大缩小时 会有损画质

55
00:02:58.580 --> 00:03:01.840
所以通常来说 在生成了位图格式的图形后

56
00:03:01.840 --> 00:03:04.330
不应该再进行缩放操作

57
00:03:04.330 --> 00:03:07.360
当然 任何电脑或网页浏览器都能读取 JPEG 格式的图片

58
00:03:07.360 --> 00:03:11.380
因此它们也非常适用于网络上的图形

59
00:03:11.380 --> 00:03:15.510
但它们却不怎么适合用在线条图形上

60
00:03:15.510 --> 00:03:20.960
大家只要生成一个 JPEG 格式的线条图 就能发现一些线条会失真

61
00:03:20.960 --> 00:03:25.032
TIFF 格式是另一个较为老旧的位图格式文件

62
00:03:25.032 --> 00:03:27.368
这一格式支持无损压缩

63
00:03:27.368 --> 00:03:30.916
现今仍在广泛使用

64
00:03:30.916 --> 00:03:34.030
BMP 格式是供 Windows 使用的位图文件格式

65
00:03:34.030 --> 00:03:36.000
较常用在图标图形上

66
00:03:39.708 --> 00:03:42.872
我们也可以同时打开多个图形设备

67
00:03:42.872 --> 00:03:46.290
打个比方来说

68
00:03:46.290 --> 00:03:48.910
你可能会想同时生成三或四个不同图形来看看

69
00:03:48.910 --> 00:03:50.710
要想这么做

70
00:03:50.710 --> 00:03:53.960
就必须同时打开三到四个不同的屏幕设备

71
00:03:55.070 --> 00:03:59.480
你可以这么做 你可以直接先打开图形设备

72
00:03:59.480 --> 00:04:02.450
好比在 Mac 通过多次调用 quartz() 打开屏幕设备

73
00:04:02.450 --> 00:04:04.860
好比在 Mac 通过多次调用 quartz() 打开屏幕设备

74
00:04:04.860 --> 00:04:08.100
这样一来就能打开多个屏幕设备

75
00:04:09.330 --> 00:04:12.460
话虽如此 但你每次只能在一个设备上进行绘制

76
00:04:12.460 --> 00:04:15.150
你正在绘制图形的图形设备

77
00:04:15.150 --> 00:04:18.030
也就是当前活动的图形设备

78
00:04:18.030 --> 00:04:20.570
你可以通过调用 dev.cur() 来查看当前活动设备 cur 是 current 的缩写

79
00:04:20.570 --> 00:04:23.829
你可以通过调用 dev.cur() 来查看当前活动设备 cur 是 current 的缩写

80
00:04:25.530 --> 00:04:29.900
该函数会返回一个整数

81
00:04:29.900 --> 00:04:31.440
该数就代表了当前活动的窗口

82
00:04:31.440 --> 00:04:33.720
也就是说 每个图形窗口都赋了一个整数值

83
00:04:33.720 --> 00:04:38.240
从2开始往上计算

84
00:04:38.240 --> 00:04:40.550
所以不存在值为 1 的图形设备

85
00:04:40.550 --> 00:04:43.560
每个图形设备都会赋一个整数

86
00:04:43.560 --> 00:04:48.024
你可以通过 dev.set() 来改变当前的活动图形设备

87
00:04:48.024 --> 00:04:52.220
给 dev.set() 函数输入一个整数值

88
00:04:52.220 --> 00:04:54.960
这样就可以切换到对应数值的那一个图形设备

89
00:04:54.960 --> 00:04:56.480
这样就可以切换到对应数值的那一个图形设备

90
00:04:56.480 --> 00:04:57.880
因此在需要的时候 便可以通过 dev.set() 在多个图形设备之间来回切换

91
00:04:57.880 --> 00:05:01.510
因此在需要的时候 便可以通过 dev.set() 在多个图形设备之间来回切换

92
00:05:04.970 --> 00:05:09.180
最后 你也可以在不同设备之间对图像进行复制黏贴

93
00:05:09.180 --> 00:05:11.940
这种处理方式非常常见

94
00:05:11.940 --> 00:05:14.410
当你在屏幕上生成了一个图形

95
00:05:14.410 --> 00:05:16.400
你对自己的成果非常满意

96
00:05:16.400 --> 00:05:19.060
接着你想将其写入一个文件当中

97
00:05:19.060 --> 00:05:20.490
有两个方法

98
00:05:20.490 --> 00:05:23.440
其中一个 如果你保存了能在屏幕上显示图像的代码

99
00:05:23.440 --> 00:05:25.240
其中一个 如果你保存了能在屏幕上显示图像的代码

100
00:05:25.240 --> 00:05:30.370
你可以直接打开一个文件设备 直接将代码剪切黏贴进 R

101
00:05:30.370 --> 00:05:34.560
接着关上文件设备 这样一来你就将图形写入文件当中了

102
00:05:34.560 --> 00:05:37.820
但还有个更快更简便的方法

103
00:05:37.820 --> 00:05:42.250
直接将图形从屏幕设备复制进文件设备中

104
00:05:42.250 --> 00:05:45.270
你可以用 dev.copy() 来完成这种操作

105
00:05:45.270 --> 00:05:48.110
将图形从任一设备中复制到任意其它设备

106
00:05:48.110 --> 00:05:51.340
但如果你非常明确地想要一个 PDF 文件

107
00:05:51.340 --> 00:05:55.780
那么 有这么一个叫做 dev.copy2pdf 的函数

108
00:05:55.780 --> 00:05:58.600
就能把图形直接从屏幕设备上复制进 PDF 文件

109
00:06:00.380 --> 00:06:02.874
有一点非常重要 即复制图形这一操作

110
00:06:02.874 --> 00:06:05.368
并不是一个一比一的过程

111
00:06:05.368 --> 00:06:07.514
因此你最后得到的文件

112
00:06:07.514 --> 00:06:09.870
或许并不一定与你在屏幕上看到的图形相同

113
00:06:09.870 --> 00:06:13.360
所以你可能会需要做些调整

114
00:06:13.360 --> 00:06:15.950
这里 这些代码会在屏幕上生成一个图形

115
00:06:15.950 --> 00:06:18.850
这是 R 自带的关于老忠实间歇泉的数据

116
00:06:18.850 --> 00:06:20.870
我想将其复制进一个 PNG 文件

117
00:06:20.870 --> 00:06:24.600
也就是说 我想在电脑上创建一个 PNG 文件

118
00:06:24.600 --> 00:06:26.850
其中包含的图形与我在屏幕上看到的一致

119
00:06:26.850 --> 00:06:31.320
我先调用 dev.copy() 其中的第一个实参

120
00:06:31.320 --> 00:06:35.300
是用来打开文件设备的函数 在这里便是 png 函数

121
00:06:36.350 --> 00:06:38.920
接着 取个文件名 这对创建文件来说是必须的

122
00:06:38.920 --> 00:06:40.730
我把它命名为 geiserplot.png

123
00:06:40.730 --> 00:06:43.450
随后 在复制了图形之后

124
00:06:43.450 --> 00:06:47.350
我还需要用 dev.off() 来关闭 PNG 设备

125
00:06:47.350 --> 00:06:49.910
一旦调用了 dev.off()

126
00:06:49.910 --> 00:06:53.110
我的电脑上应该会出现一个 PNG 格式的文件

127
00:06:53.110 --> 00:06:55.810
我可以将其发送给他人 或是添加进我的演示文档当中

128
00:06:59.090 --> 00:07:03.750
那么 这是关于 R 图形设备的一个快速汇总

129
00:07:03.750 --> 00:07:07.450
最重要的一点是 所有图形都要通过图形设备才能生成

130
00:07:08.630 --> 00:07:13.280
一般来说都是用屏幕设备 这对探索性分析来说非常有用

131
00:07:13.280 --> 00:07:15.560
但如果你想保存成图像 或将其发送给他人

132
00:07:15.560 --> 00:07:17.780
那么你就需要在文件设备中生成图形了

133
00:07:18.840 --> 00:07:20.830
对此 有许多不同的文件格式可供你选择

134
00:07:20.830 --> 00:07:24.975
有 PDF 或 SVG 等的矢量格式

135
00:07:24.975 --> 00:07:29.270
也有类似 PNG 和 JPEG等的位图格式可供选择
【教育无边界字幕组】LennyBear | 养不肥的猪 | 詹詹詹米