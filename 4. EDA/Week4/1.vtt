WEBVTT

1
00:00:03.190 --> 00:00:04.580
在这个案例研究中 我将会更多地讨论探索性数据分析的技术

2
00:00:04.580 --> 00:00:07.870
在这个案例研究中 我将会更多地讨论探索性数据分析的技术

3
00:00:07.870 --> 00:00:10.060
以及如何将它们运用到一个涉及用智能手机来预测人类活动的数据集上

4
00:00:10.060 --> 00:00:14.060
以及如何将它们运用到一个涉及用智能手机来预测人类活动的数据集上

5
00:00:14.060 --> 00:00:17.120
首先你要记住 在任何的探索性数据分析中

6
00:00:17.120 --> 00:00:19.350
你都要清楚你的目标是什么

7
00:00:19.350 --> 00:00:20.970
你想要从你的数据集中得到的重点可能是什么

8
00:00:20.970 --> 00:00:23.930
你想要从你的数据集中得到的重点可能是什么

9
00:00:23.930 --> 00:00:28.220
这些想法会引导你完成你的目标 还能在方法上对你有所启发

10
00:00:28.220 --> 00:00:31.310
记住 探索性数据分析的基本思想是

11
00:00:31.310 --> 00:00:33.550
记住 探索性数据分析的基本思想是

12
00:00:33.550 --> 00:00:36.840
你要对你最终想要得到的结果有粗略的构想

13
00:00:36.840 --> 00:00:40.080
这个构想不用很完美

14
00:00:40.080 --> 00:00:43.000
不需要有很完善的细节

15
00:00:43.000 --> 00:00:45.210
但它可以粗略地告诉你

16
00:00:45.210 --> 00:00:47.610
你大概能从这些数据里得到什么信息

17
00:00:47.610 --> 00:00:49.960
以及你可以回答哪些问题

18
00:00:49.960 --> 00:00:53.590
还有凭借给定的数据仍然不能回答哪些问题

19
00:00:53.590 --> 00:00:56.140
还有凭借给定的数据仍然不能回答哪些问题

20
00:00:56.140 --> 00:00:59.130
因此 探索性数据分析十分重要

21
00:00:59.130 --> 00:01:03.330
它可以排除特定的问题 迫使你沿着另一些方向前进

22
00:01:03.330 --> 00:01:04.790
它可以帮助你得到一个粗略的分析结果

23
00:01:04.790 --> 00:01:07.870
来帮助你进入下一个阶段

24
00:01:07.870 --> 00:01:09.710
现在我们来看看本例里面的 Samsung (三星) 数据

25
00:01:09.710 --> 00:01:11.640
看看我们能发现什么

26
00:01:19.700 --> 00:01:21.790
这个数据集来自于加州大学欧文分校 (University of California Irvine) 机器学习档案

27
00:01:21.790 --> 00:01:26.150
这个数据集来自于加州大学欧文分校 (University of California Irvine) 机器学习档案

28
00:01:26.150 --> 00:01:29.225
它通过三星 Galaxy 手机来预测人们的行动

29
00:01:29.225 --> 00:01:33.730
它通过三星 Galaxy 手机来预测人们的行动

30
00:01:33.730 --> 00:01:36.448
这是一张三星 Galaxy S3 的图片

31
00:01:36.448 --> 00:01:39.424
真实的数据是使用 Galaxy S2 来生成的

32
00:01:39.424 --> 00:01:42.720
但是基本思想都是一样的

33
00:01:42.720 --> 00:01:44.900
在每一台这样的手机里面

34
00:01:44.900 --> 00:01:47.940
都有一个加速度计 (accelerometer) 和一个陀螺仪 (gyroscope)

35
00:01:47.940 --> 00:01:50.360
可以通过它们来得知一个人的三维位置以及加速度

36
00:01:50.360 --> 00:01:54.290
可以通过它们来得知一个人的三维位置以及加速度

37
00:01:54.290 --> 00:01:55.960
只要这个人手里拿着手机就行

38
00:01:57.160 --> 00:01:59.220
这个数据集就是从这里得到的

39
00:01:59.220 --> 00:02:01.080
这是加州大学欧文分校的机器学习知识库

40
00:02:01.080 --> 00:02:04.400
你可以点击这个链接来更多地了解这个数据集

41
00:02:04.400 --> 00:02:08.520
比如 它是怎么收集数据的 网站里还有什么可用的东西等等

42
00:02:08.520 --> 00:02:10.300
我已经下载了这个数据集的一个子集

43
00:02:10.300 --> 00:02:12.600
我已经下载了这个数据集的一个子集

44
00:02:12.600 --> 00:02:16.451
把它作为这节课的训练数据集

45
00:02:18.310 --> 00:02:21.830
这个数据已经被稍微加工过 让它用起来更方便

46
00:02:21.830 --> 00:02:25.870
你现在有了一个矩阵

47
00:02:25.870 --> 00:02:30.480
它的行代表观测值 列表示不同的特征

48
00:02:30.480 --> 00:02:32.770
你可以看到 在底部

49
00:02:32.770 --> 00:02:35.280
每一行都有一些活动标签

50
00:02:35.280 --> 00:02:40.460
来告诉你在那个时刻那个人正在做什么

51
00:02:40.460 --> 00:02:42.760
比方说 这里有六个可能的活动

52
00:02:42.760 --> 00:02:45.500
躺着、坐着、 站着

53
00:02:45.500 --> 00:02:48.000
走着、往下走、往上走

54
00:02:49.048 --> 00:02:51.170
这里的想法是

55
00:02:51.170 --> 00:02:53.590
你想要通过不同的特征把这六个活动区分出来

56
00:02:53.590 --> 00:02:56.410
你想要通过不同的特征把这六个活动区分出来

57
00:02:56.410 --> 00:03:00.040
而这些特征正是加速度计和陀螺仪收集的

58
00:03:00.040 --> 00:03:00.530
在这里

59
00:03:00.530 --> 00:03:03.980
我列出了最前面的 12 个特征

60
00:03:03.980 --> 00:03:06.760
比如 身体加速度里面的均值

61
00:03:06.760 --> 00:03:09.870
标准差、平均绝对偏差 (mean absolute deviation)

62
00:03:09.870 --> 00:03:11.940
以及每个特征的最大值

63
00:03:15.140 --> 00:03:17.070
我们首先可以很快完成的是

64
00:03:17.070 --> 00:03:19.590
观察一下第一个对象的平均加速度

65
00:03:19.590 --> 00:03:20.960
我要做的第一件事是

66
00:03:20.960 --> 00:03:25.380
把活动变量转换成因子变量

67
00:03:25.380 --> 00:03:27.920
使用 transform()

68
00:03:27.920 --> 00:03:30.930
然后把第一个对象提取出来

69
00:03:30.930 --> 00:03:35.160
也就是令 subject 等于1 在本讲接下来的时间里

70
00:03:35.160 --> 00:03:37.960
我要暂时忽略其它所有的对象

71
00:03:37.960 --> 00:03:39.430
那么

72
00:03:39.430 --> 00:03:40.360
如果我画出第一个对象

73
00:03:40.360 --> 00:03:42.850
我就能看到它的第一列

74
00:03:42.850 --> 00:03:45.790
也就是在 x 方向上的平均身体加速度

75
00:03:45.790 --> 00:03:48.300
也就是在 x 方向上的平均身体加速度

76
00:03:48.300 --> 00:03:51.500
加速度要分解成 x、y、z 三个维度

77
00:03:52.550 --> 00:03:54.100
第二个图则是

78
00:03:54.100 --> 00:03:56.860
在 y 方向上的平均身体加速度

79
00:03:56.860 --> 00:04:00.260
在 y 方向上的平均身体加速度

80
00:04:00.260 --> 00:04:06.190
并且我已经把每个活动都用颜色编码了

81
00:04:06.190 --> 00:04:08.570
并且我已经把每个活动都用颜色编码了

82
00:04:08.570 --> 00:04:10.840
例如 你可以看到 在左边的图里

83
00:04:10.840 --> 00:04:14.260
有绿色、红色、黑色、蓝色 等等

84
00:04:14.260 --> 00:04:15.830
这些都是各种各样的活动

85
00:04:15.830 --> 00:04:18.540
左边图像的问题在于每个颜色对应什么活动

86
00:04:18.540 --> 00:04:22.150
所以在右边的图像里 我用 legend() 加入了一个图例

87
00:04:22.150 --> 00:04:25.340
这样你就可以知道每个颜色对应的活动了

88
00:04:25.340 --> 00:04:27.220
现在你可以看到

89
00:04:27.220 --> 00:04:30.950
绿色表示站着 红色表示坐着 黑色表示躺着 等等

90
00:04:30.950 --> 00:04:36.950
可以看到 平均身体加速度在站着、坐着、躺着的时候相对没什么变化

91
00:04:36.950 --> 00:04:42.270
可以看到 平均身体加速度在坐着、站着、躺着的时候相对没什么变化

92
00:04:42.270 --> 00:04:43.820
但是当变成 走路、向下走、向上走之后

93
00:04:43.820 --> 00:04:46.630
在 x 方向上 平均身体加速度就有了更多的变化

94
00:04:46.630 --> 00:04:49.300
在 x 方向上 平均身体加速度就有了更多的变化

95
00:04:50.910 --> 00:04:53.490
我们可以试着用平均加速度对数据进行聚类

96
00:04:53.490 --> 00:04:55.870
我只用了这个矩阵的前三列

97
00:04:55.870 --> 00:05:00.320
然后用 dist() 得到了一个距离矩阵

98
00:05:00.320 --> 00:05:03.020
在这里我使用的是默认的欧式距离 (Euclidean distance)

99
00:05:03.020 --> 00:05:04.900
然后调用 hclust()

100
00:05:04.900 --> 00:05:08.590
来对这些数据做一个层次聚类 (Hierarchical Clustering)

101
00:05:08.590 --> 00:05:11.390
接着调用 myplclust() 使这个聚类可视化

102
00:05:11.390 --> 00:05:15.140
你可以看到这个聚类有一点杂乱无章

103
00:05:15.140 --> 00:05:17.880
里面没有什么明显的规律

104
00:05:17.880 --> 00:05:20.310
所有的颜色都在底部混在一起

105
00:05:20.310 --> 00:05:20.890
所以我们可能需要

106
00:05:20.890 --> 00:05:22.130
进一步地观察

107
00:05:22.130 --> 00:05:25.080
并试着在这里得到更多的信息

108
00:05:26.980 --> 00:05:28.050
我们可以关注的另一件事是

109
00:05:28.050 --> 00:05:31.670
第一个对象的最大加速度

110
00:05:31.670 --> 00:05:34.980
在这里我画出了第 10 和 11 列

111
00:05:34.980 --> 00:05:39.740
可以看的 第 10 列 是 x 方向上的最大身体加速度

112
00:05:39.740 --> 00:05:42.260
11 列则是

113
00:05:42.260 --> 00:05:44.630
y 方向上的最大身体加速度

114
00:05:44.630 --> 00:05:46.060
可以再次看到

115
00:05:46.060 --> 00:05:48.670
对于躺着、站着以及坐着来说

116
00:05:48.670 --> 00:05:50.900
图像上没有太多的变化

117
00:05:50.900 --> 00:05:53.760
但是对于走路、向上走以及向下走来说

118
00:05:53.760 --> 00:05:58.680
最大加速度表现出了较高的变异性

119
00:05:58.680 --> 00:06:03.208
可能预示了这些活动的发生

120
00:06:03.208 --> 00:06:07.220
可以预先地把运动和不运动区分开来

121
00:06:07.220 --> 00:06:10.105
这种区分在回溯的时候还是比较明显的

122
00:06:10.105 --> 00:06:11.350
那么

123
00:06:11.350 --> 00:06:16.180
如果你根据最大加速度来聚类数据的话 你可以看到

124
00:06:16.180 --> 00:06:18.150
左手边有两个非常明显的簇

125
00:06:18.150 --> 00:06:20.530
它们是诸如走路之类的活动

126
00:06:20.530 --> 00:06:21.650
在右手边则是

127
00:06:21.650 --> 00:06:25.150
非运动的活动 躺着、站着和坐着

128
00:06:25.150 --> 00:06:28.224
除此之外 其他都混在一起

129
00:06:28.224 --> 00:06:31.050
在左边有一大块青绿色

130
00:06:31.050 --> 00:06:33.000
很明显那代表一个活动

131
00:06:33.000 --> 00:06:34.910
但是蓝色和洋红色则混合在了一起

132
00:06:35.920 --> 00:06:36.333
因此

133
00:06:36.333 --> 00:06:39.755
基于最大加速度的聚类看起来把运动和非运动区别了开来

134
00:06:39.755 --> 00:06:43.770
但你一旦进入到簇里面

135
00:06:43.770 --> 00:06:45.440
比如 进入运动簇或是非运动簇

136
00:06:45.440 --> 00:06:48.340
比如 进入运动簇或是非运动簇

137
00:06:48.340 --> 00:06:51.890
想要再仅仅根据最大加速度来分辨不同的类别就变得比较困难了

138
00:06:54.630 --> 00:06:57.290
我们可以尝试一下对这个数据进行奇异值分解 (Singular Value Decomposition)

139
00:06:57.290 --> 00:06:59.270
来探索一下到底是怎么回事

140
00:06:59.270 --> 00:07:02.020
在我做分解之前 我要对所有的 560 多列数据做分解

141
00:07:02.020 --> 00:07:05.480
在我做分解之前 我要对所有的 560 多列数据做分解

142
00:07:05.480 --> 00:07:07.940
我要先把最后的两列去掉

143
00:07:07.940 --> 00:07:10.540
它们只是活动标识符和对象标识符

144
00:07:10.540 --> 00:07:12.690
并不是我们感兴趣的数据

145
00:07:12.690 --> 00:07:14.990
把 562、563 两列去掉之后 我就可以进行奇异值分解了

146
00:07:14.990 --> 00:07:17.950
把 562、563 两列去掉之后 我就可以进行奇异值分解了

147
00:07:19.160 --> 00:07:19.970
你可以看到

148
00:07:19.970 --> 00:07:21.330
我要看一下第一个和第二个左奇异向量

149
00:07:21.330 --> 00:07:25.290
然后根据活动用颜色给它们编码

150
00:07:25.290 --> 00:07:27.910
你可以发现这里还是有一个类似的规律

151
00:07:27.910 --> 00:07:29.750
第一个奇异向量看起来

152
00:07:29.750 --> 00:07:32.440
确实把运动和非运动区别开来了

153
00:07:32.440 --> 00:07:37.490
你可以看到你可以看到底部有绿色、红色和黑色

154
00:07:37.490 --> 00:07:40.000
在上方则是蓝色、青绿色以及洋红色

155
00:07:41.230 --> 00:07:45.410
第二个奇异向量则显得没有那么清楚

156
00:07:45.410 --> 00:07:46.960
第二个奇异向量则显得没有那么清楚

157
00:07:46.960 --> 00:07:52.920
看起来它把洋红色和其它所有的簇都分开来了

158
00:07:52.920 --> 00:07:57.890
所以我认为这表示向上走或是向下走

159
00:07:57.890 --> 00:08:00.860
因此第二个奇异向量中有什么亮点还不清楚

160
00:08:00.860 --> 00:08:04.180
因此第二个奇异向量中有什么亮点还不清楚

161
00:08:07.070 --> 00:08:08.200
我们可以做的一件事是

162
00:08:08.200 --> 00:08:11.120
试着去发现最大贡献者

163
00:08:11.120 --> 00:08:15.310
在第二个右奇异向量里

164
00:08:15.310 --> 00:08:18.530
我们要努力找出

165
00:08:19.650 --> 00:08:23.800
哪一个特征导致了最大的变异

166
00:08:23.800 --> 00:08:25.340
也就是对不同的观测间值的变化做了最大的贡献

167
00:08:25.340 --> 00:08:30.250
也就是对不同的观测间值的变化做了最大的贡献

168
00:08:30.250 --> 00:08:32.480
那么

169
00:08:32.480 --> 00:08:35.130
我们可以使用 which.max() 来找到

170
00:08:35.130 --> 00:08:38.900
在这 500 多个特征中

171
00:08:38.900 --> 00:08:42.860
哪一个对观测值间的变化做了最多的贡献

172
00:08:42.860 --> 00:08:48.240
我把它赋给 maxContrib 对象

173
00:08:48.240 --> 00:08:49.950
接着我要基于最大加速度加上这个特征来进行聚类

174
00:08:49.950 --> 00:08:53.340
接着我要基于最大加速度加上这个特征来进行聚类

175
00:08:53.340 --> 00:08:57.580
然后再计算距离矩阵 运行 hclust() 接着你就可以看到

176
00:08:57.580 --> 00:08:59.770
不同的活动看起来比之前区分得更开了一点

177
00:08:59.770 --> 00:09:03.840
至少三个运动活动很明显地被分开了

178
00:09:03.840 --> 00:09:07.670
我们现在把洋红、深蓝以及青绿色都分开了

179
00:09:07.670 --> 00:09:11.790
而所有的非运动活动

180
00:09:11.790 --> 00:09:16.432
看起来仍然混合在一块 无论这个最大贡献者是什么

181
00:09:16.432 --> 00:09:19.990
它都没有很好地帮我们区分出这些非运动活动

182
00:09:19.990 --> 00:09:23.020
但是它在区分运动活动时对我们帮助很大

183
00:09:25.830 --> 00:09:30.930
这个最大贡献者是 z 方向上的频域 (frequency domain) 上的平均身体加速度

184
00:09:30.930 --> 00:09:34.810
这个最大贡献者是 z 方向上的频域 (frequency domain) 上的平均身体加速度

185
00:09:34.810 --> 00:09:37.930
这是一类身体加速度

186
00:09:37.930 --> 00:09:40.900
在 z 方向上的

187
00:09:40.900 --> 00:09:43.510
对其进行变换以得到频域成分

188
00:09:43.510 --> 00:09:44.680
这是挺有意思的

189
00:09:44.680 --> 00:09:50.315
我们可以尝试另一种聚类技术 即 K-均值聚类 (K-means clustering)

190
00:09:50.315 --> 00:09:51.290
并且

191
00:09:51.290 --> 00:09:53.350
对于 K-均值聚类来说

192
00:09:53.350 --> 00:09:55.000
你要关心的一点是

193
00:09:55.000 --> 00:09:57.780
你得到的结果会取决于

194
00:09:57.780 --> 00:10:01.060
不同的初始值

195
00:10:01.060 --> 00:10:02.990
以及运行次数

196
00:10:02.990 --> 00:10:04.960
所以当你使用 K-均值聚类时 必须指定一个起始点

197
00:10:04.960 --> 00:10:07.500
以此来指定聚类的中心

198
00:10:07.500 --> 00:10:10.230
大多数的算法都会指定一个随机的起始点

199
00:10:10.230 --> 00:10:12.150
所以如果你选择了一个随机的起始点

200
00:10:12.150 --> 00:10:14.330
你可能会得到一个次优的结果

201
00:10:14.330 --> 00:10:16.330
如果你选择了一个不一样的起始点

202
00:10:16.330 --> 00:10:18.100
你可能会得到一个更好的结果

203
00:10:18.100 --> 00:10:23.420
一般来说让 nstart 的值大于 1 是比较好的

204
00:10:23.420 --> 00:10:24.880
你可以尝试不同的起始值

205
00:10:24.880 --> 00:10:27.900
来得到更优解

206
00:10:27.900 --> 00:10:32.290
这是一个用 K-均值聚类得到的聚类结果

207
00:10:32.290 --> 00:10:35.830
你可以看到

208
00:10:35.830 --> 00:10:37.450
我给定了六个中心 因为我知道这里总共有六个簇

209
00:10:37.450 --> 00:10:39.710
所以我现在就给出了它们

210
00:10:39.710 --> 00:10:41.120
还可以看到

211
00:10:41.120 --> 00:10:43.340
有些簇间出现了重叠

212
00:10:43.340 --> 00:10:45.080
比如 3 号簇

213
00:10:45.080 --> 00:10:47.970
它是躺着、坐着、站着的组合

214
00:10:47.970 --> 00:10:51.430
而 1 号簇则明显是走路

215
00:10:51.430 --> 00:10:52.680
2 号簇是向下走

216
00:10:52.680 --> 00:10:57.940
4 号簇是向上走 5 号簇是走路

217
00:10:57.940 --> 00:11:02.340
6 号簇也是躺着、坐着和站着的组合

218
00:11:02.340 --> 00:11:06.460
因此你可以看到 K-平均值法在这里遇到了一些困难

219
00:11:06.460 --> 00:11:09.580
它不能在聚类中把躺着、坐着和站着三种行动区分出来

220
00:11:09.580 --> 00:11:12.390
它不能在聚类中把躺着、坐着和站着三种行动区分出来

221
00:11:13.750 --> 00:11:16.540
如果你再试一次的话 你可以看到 现在的排列变得不太一样了

222
00:11:16.540 --> 00:11:19.460
但是 2 号簇仍然是躺着、坐着和站着的组合

223
00:11:19.460 --> 00:11:23.190
5 号簇也是一样

224
00:11:23.190 --> 00:11:26.350
然而其它的簇则看起来分组很明晰

225
00:11:26.350 --> 00:11:29.510
然而其它的簇则看起来分组很明晰

226
00:11:30.810 --> 00:11:31.480
现在

227
00:11:31.480 --> 00:11:34.320
我们尝试了 100 个不同的起始值

228
00:11:34.320 --> 00:11:37.281
再取出当中最优的解

229
00:11:38.820 --> 00:11:40.650
你可以看到各个活动区分得稍微好了一点

230
00:11:40.650 --> 00:11:42.900
但相比上次进步并不明显

231
00:11:42.900 --> 00:11:46.720
可以看到 1 号簇仍然是躺着、坐着和站着的组合

232
00:11:46.720 --> 00:11:48.080
2 号簇只有躺着

233
00:11:48.080 --> 00:11:53.112
3 号簇只有走路 4 号簇只有向下走

234
00:11:53.112 --> 00:11:57.390
你可以看到这些活动是如何被聚类的

235
00:11:57.390 --> 00:12:00.270
我要再用 100 个起始值试一次

236
00:12:00.270 --> 00:12:02.560
可以看到 这大概将是我们得到的最好结果了

237
00:12:02.560 --> 00:12:04.580
6 号簇仍然是三个活动的组合

238
00:12:04.580 --> 00:12:08.450
5 号簇则是两个活动的组合

239
00:12:08.450 --> 00:12:11.970
所以我们可以知道聚类的中心在哪儿

240
00:12:11.970 --> 00:12:14.880
这里的思想就在于

241
00:12:14.880 --> 00:12:18.830
在这个 500 维的空间里 每一个簇都有一个均值 也就是中心

242
00:12:18.830 --> 00:12:22.482
因此我们可以看到这 500 个特征中的某些特征

243
00:12:22.482 --> 00:12:27.940
看起来决定了给定簇的中心之位置

244
00:12:27.940 --> 00:12:33.190
这可以帮助我们了解

245
00:12:33.190 --> 00:12:35.140
哪些特征在将人或观测值聚到这个簇中起了重要作用

246
00:12:35.140 --> 00:12:38.610
哪些特征在将人或观测值聚到这个簇中起了重要作用

247
00:12:38.610 --> 00:12:42.170
看第一个簇 它对应躺着

248
00:12:42.170 --> 00:12:47.660
你可以看到它的中心里面的前三个特征都有较高的正值

249
00:12:49.450 --> 00:12:52.550
也就是平均身体加速度

250
00:12:52.550 --> 00:12:54.639
其它的特征的值则比较低

251
00:12:56.290 --> 00:12:58.780
也就是后面的特征 4 到 10

252
00:12:58.780 --> 00:13:02.260
我在这里只画出了 500 多个特征的前 10 个

253
00:13:02.260 --> 00:13:04.010
现在看第二个簇

254
00:13:05.200 --> 00:13:08.680
它在其它特征上有一些比较有趣的值

255
00:13:08.680 --> 00:13:11.340
它在其它特征上有一些比较有趣的值

256
00:13:11.340 --> 00:13:14.700
除了平均加速度之外还有最大加速度

257
00:13:14.700 --> 00:13:18.330
它看起来也有一些有趣的值

258
00:13:18.330 --> 00:13:20.620
因此 你可以通过观察聚类中心

259
00:13:20.620 --> 00:13:23.000
因此 你可以通过观察聚类中心

260
00:13:23.000 --> 00:13:25.520
找到那些数值引人关注的特征

261
00:13:25.520 --> 00:13:28.750
它们决定了中心的位置

262
00:13:28.750 --> 00:13:32.800
同时 还要知道在有效预测活动这方面 哪些特征最有用

263
00:13:32.800 --> 00:13:36.217
上面的内容只是一个简短的演示

264
00:13:36.217 --> 00:13:40.570
用来让大家了解如何处理一个有很多特征和观测值的数据集

265
00:13:40.570 --> 00:13:43.160
同时也涉及了一点各种聚类技术

266
00:13:43.160 --> 00:13:45.410
我们用了层次聚类、K-均值聚类

267
00:13:45.410 --> 00:13:47.490
还用了奇异值分解

268
00:13:47.490 --> 00:13:51.150
来观察这个数据集多方面的特征

269
00:13:51.150 --> 00:13:53.420
学了这些之后

270
00:13:53.420 --> 00:13:57.960
我们就会想要继续探讨如何区别出不同的非运动活动

271
00:13:57.960 --> 00:14:01.020
从躺着、坐着和站着这三方面来说

272
00:14:01.020 --> 00:14:03.120
我们区分起来还有些困难

273
00:14:03.120 --> 00:14:05.920
至少在第一眼看来是这样的

274
00:14:05.920 --> 00:14:07.800
而运动活动 也就是走路

275
00:14:07.800 --> 00:14:09.600
向上走、向下走来说

276
00:14:09.600 --> 00:14:12.550
我们看起来已经能够把它们分到不同的簇里去了

277
00:14:12.550 --> 00:14:16.680
通常来说只要用一些变量即可 而它们大部分都是最大加速度变量

278
00:14:16.680 --> 00:14:20.490
但是非运动活动则看起来更难区分

279
00:14:20.490 --> 00:14:23.200
而探索性数据分析的好处就在于

280
00:14:23.200 --> 00:14:26.160
它给了你这个大概的框架 告诉你往哪里分配精力

281
00:14:26.160 --> 00:14:28.200
所以你不会想要在运动活动上面花费太多的力气

282
00:14:28.200 --> 00:14:30.860
但是你应该会想要

283
00:14:30.860 --> 00:14:34.670
在非运动活动上面进一步研究一下

284
00:14:34.670 --> 00:14:38.580
总之 我希望这节课在聚类技术入门

285
00:14:38.580 --> 00:14:44.010
如何观察数据、推进你的分析

286
00:14:44.010 --> 00:14:49.700
以及帮助你进行更多正式分析方面能有所帮助
【教育无边界字幕组】三又木君 | 养不肥的猪 | HikaruSama